{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Mining Pendahuluan \u00b6 Pengertian Data Mining \u00b6 Data Mining adalah proses yang menggunakan teknik statistik, matematika, kecerdasan buatan, machine learning untuk mengekstraksi dan mengidentifikasi informasi yang bermanfaat dan pengetahuan yang terkait dari berbagai database besar (Turban dkk. 2005) . Menurut Gatner Group data mining adalah suatu proses menemukan hubungan yang berarti, pola dan kecenderungan dengan memeriksa dalam sekumpulan besar data yang tersimpan dalam penyimpanan, dengan menggunakan teknik pengenalan pola seperti teknik statistik dan matematika (Larose,2005) . Secara sederhana data mining adalah penambangan atau penemuan informasi baru dengan mencari pola atau aturan tertentu dari sejumlah data yang sangat besar (Davies, 2004) . Data mining juga disebut sebagai serangkaian proses untuk menggali nilai tambah berupa pengetahuan yang selama ini tidak diketahui secara manual dari suatu kumpulan data (Pramudiono, 2007) . \u200b Karakteristik Data Mining \u00b6 Karakteristik menurut (Davies, 2004) : Data mining berhubungan dengan penemuan sesuatu yang tersembunyi dan pola data tertentu yang tidak diketahui sebelumnya. Data mining biasa menggunakan data yang sangat besar. Biasanya data yang besar digunakan untuk membuat hasil lebih dipercaya. Data mining berguna untuk membuat keputusan yang kritis, terutama dalam strategi. Tahapan Data Mining \u00b6 Data Cleaning membuang data yang tidak konsisten dan noise \u00b6 Pada umumnya data yang diperoleh, baik dari database suatu perusahaan maupun hasil eksperimen, memiliki isian-isian yang tidak sempurna seperti data yang hilang, data yang tidak valid atau juga hanya sekedar salah ketik. Garbage in garbage out (hanya sampah yang akan dihasilkan bila yang dimasukkan juga sampah) merupakan istilah yang sering dipakai untuk menggambarkan tahap ini. Pembersihan data juga akan mempengaruhi performasi dari sistem data mining karena data yang ditangani akan berkurang jumlah dan kompleksitasnya. Jadi intinya Pembersihan data adalah untuk menghilangkan data yang tidak berguna atau cacat. Integration Data penggabungan data dari beberapa sumber \u00b6 Tidak jarang data yang diperlukan untuk data mining tidak hanya berasal dari satu database tetapi juga berasal dari beberapa database atau file teks. Integrasi data dilakukan pada atribut-aribut yang mengidentifikasikan entitas-entitas yang unik seperti atribut nama, jenis produk, nomor pelanggan dsb. Integrasi data perlu dilakukan secara cermat karena kesalahan pada integrasi data bisa menghasilkan hasil yang menyimpang dan bahkan menyesatkan pengambilan aksi nantinya. Dalam integrasi data ini juga perlu dilakukan transformasi dan pembersihan data karena seringkali data dari dua database berbeda tidak sama cara penulisannya atau bahkan data yang ada di satu database ternyata tidak ada di database lainnya. Sebagai contoh bila integrasi data berdasarkan jenis produk ternyata menggabungkan produk dari kategori yang berbeda maka akan didapatkan korelasi antar produk yang sebenarnya tidak ada. Inti dari Integrasi data adalah menghubungkan beberapa data untuk memudahkan pengambilan keputusan Data Transformation perubahan menjadi bentuk yang sesuai untuk di-mining \u00b6 Data diubah atau digabung ke dalam format yang sesuai untuk diproses dalam data mining. Beberapa metode data mining membutuhkan format data yang khusus sebelum bisa diaplikasikan. Seperti analisis asosiasi dan klastering hanya bisa menerima input data kategorikal. Karenanya data berupa angka numerik yang berlanjut perlu dibagi-bagi menjadi beberapa interval, proses ini sering disebut binning. Data Mining pengaplikasian teknik data mining \u00b6 Aplikasi teknik data mining sendiri hanya merupakan salah satu bagian dari proses data mining. Ada beberapa teknik data mining yang sudah umum dipakai. Perlu diperhatikan bahwa ada kalanya teknik-teknik data mining umum yang tersedia di pasar tidak mencukupi untuk melaksanakan data mining di bidang tertentu atau untuk data tertentu. Sebagai contoh akhir-akhir ini dikembangkan berbagai teknik data mining baru untuk penerapan di bidang bioinformatika seperti analisa hasil microarray untuk mengidentifikasi DNA dan fungsi-fungsinya. Pattern Evaluation evaluasi guna menemukan sebuah informasi \u00b6 Dalam tahap ini hasil dari data mining berupa pola-pola yang khas maupun model prediksi dievaluasi untuk menilai apakah hipotesa yang ada memang tercapai. Bila ternyata hasil yang diperoleh tidak sesuai hipotesa ada beberapa alternatif yang dapat diambil seperti : menjadikannya umpan balik untuk memperbaiki proses data mining, mencoba teknik data mining lain yang lebih sesuai, atau menerima hasil ini sebagai suatu hasil yang di luar dugaan yang mungkin bermanfaat. Ada beberapa teknik data mining yang menghasilkan hasil analisa berjumlah besar seperti analisis asosiasi. Visualisasi hasil analisa akan sangat membantu untuk memudahkan pemahaman dari hasil data mining. Knowledge Presentation presentasi pola yang ditemukan untuk menghasilkan aksi \u00b6 Tahap terakhir dari proses data mining yang Merupakan visualisasi dan penyajian pengetahuan mengenai metode yang digunakan untuk memperoleh pengetahuan yang diperoleh pengguna dan bagaimana memformulasikan keputusan dari hasil analisis yang didapat. Link Refrensi \u00b6 https://sis.binus.ac.id/2016/12/15/tahap-tahap-data-mining/ https://www.kajianpustaka.com/2017/09/data-mining.html https://rezqiwati.wordpress.com/2009/04/24/data-mining-%E2%80%93-proses-tahapan-dan-penerapannya/ https://purwasuka.web.id/pengertian-metode-dan-tahapan-data-mining.html","title":"Data Mining"},{"location":"#data-mining-pendahuluan","text":"","title":"Data Mining Pendahuluan"},{"location":"#pengertian-data-mining","text":"Data Mining adalah proses yang menggunakan teknik statistik, matematika, kecerdasan buatan, machine learning untuk mengekstraksi dan mengidentifikasi informasi yang bermanfaat dan pengetahuan yang terkait dari berbagai database besar (Turban dkk. 2005) . Menurut Gatner Group data mining adalah suatu proses menemukan hubungan yang berarti, pola dan kecenderungan dengan memeriksa dalam sekumpulan besar data yang tersimpan dalam penyimpanan, dengan menggunakan teknik pengenalan pola seperti teknik statistik dan matematika (Larose,2005) . Secara sederhana data mining adalah penambangan atau penemuan informasi baru dengan mencari pola atau aturan tertentu dari sejumlah data yang sangat besar (Davies, 2004) . Data mining juga disebut sebagai serangkaian proses untuk menggali nilai tambah berupa pengetahuan yang selama ini tidak diketahui secara manual dari suatu kumpulan data (Pramudiono, 2007) . \u200b","title":"Pengertian Data Mining"},{"location":"#karakteristik-data-mining","text":"Karakteristik menurut (Davies, 2004) : Data mining berhubungan dengan penemuan sesuatu yang tersembunyi dan pola data tertentu yang tidak diketahui sebelumnya. Data mining biasa menggunakan data yang sangat besar. Biasanya data yang besar digunakan untuk membuat hasil lebih dipercaya. Data mining berguna untuk membuat keputusan yang kritis, terutama dalam strategi.","title":"Karakteristik Data Mining"},{"location":"#tahapan-data-mining","text":"","title":"Tahapan Data Mining"},{"location":"#data-cleaning-membuang-data-yang-tidak-konsisten-dan-noise","text":"Pada umumnya data yang diperoleh, baik dari database suatu perusahaan maupun hasil eksperimen, memiliki isian-isian yang tidak sempurna seperti data yang hilang, data yang tidak valid atau juga hanya sekedar salah ketik. Garbage in garbage out (hanya sampah yang akan dihasilkan bila yang dimasukkan juga sampah) merupakan istilah yang sering dipakai untuk menggambarkan tahap ini. Pembersihan data juga akan mempengaruhi performasi dari sistem data mining karena data yang ditangani akan berkurang jumlah dan kompleksitasnya. Jadi intinya Pembersihan data adalah untuk menghilangkan data yang tidak berguna atau cacat.","title":"Data Cleaning membuang data yang tidak konsisten dan noise"},{"location":"#integration-data-penggabungan-data-dari-beberapa-sumber","text":"Tidak jarang data yang diperlukan untuk data mining tidak hanya berasal dari satu database tetapi juga berasal dari beberapa database atau file teks. Integrasi data dilakukan pada atribut-aribut yang mengidentifikasikan entitas-entitas yang unik seperti atribut nama, jenis produk, nomor pelanggan dsb. Integrasi data perlu dilakukan secara cermat karena kesalahan pada integrasi data bisa menghasilkan hasil yang menyimpang dan bahkan menyesatkan pengambilan aksi nantinya. Dalam integrasi data ini juga perlu dilakukan transformasi dan pembersihan data karena seringkali data dari dua database berbeda tidak sama cara penulisannya atau bahkan data yang ada di satu database ternyata tidak ada di database lainnya. Sebagai contoh bila integrasi data berdasarkan jenis produk ternyata menggabungkan produk dari kategori yang berbeda maka akan didapatkan korelasi antar produk yang sebenarnya tidak ada. Inti dari Integrasi data adalah menghubungkan beberapa data untuk memudahkan pengambilan keputusan","title":"Integration Data penggabungan data dari beberapa sumber"},{"location":"#data-transformation-perubahan-menjadi-bentuk-yang-sesuai-untuk-di-mining","text":"Data diubah atau digabung ke dalam format yang sesuai untuk diproses dalam data mining. Beberapa metode data mining membutuhkan format data yang khusus sebelum bisa diaplikasikan. Seperti analisis asosiasi dan klastering hanya bisa menerima input data kategorikal. Karenanya data berupa angka numerik yang berlanjut perlu dibagi-bagi menjadi beberapa interval, proses ini sering disebut binning.","title":"Data Transformation perubahan menjadi bentuk yang sesuai untuk di-mining"},{"location":"#data-mining-pengaplikasian-teknik-data-mining","text":"Aplikasi teknik data mining sendiri hanya merupakan salah satu bagian dari proses data mining. Ada beberapa teknik data mining yang sudah umum dipakai. Perlu diperhatikan bahwa ada kalanya teknik-teknik data mining umum yang tersedia di pasar tidak mencukupi untuk melaksanakan data mining di bidang tertentu atau untuk data tertentu. Sebagai contoh akhir-akhir ini dikembangkan berbagai teknik data mining baru untuk penerapan di bidang bioinformatika seperti analisa hasil microarray untuk mengidentifikasi DNA dan fungsi-fungsinya.","title":"Data Mining pengaplikasian teknik data mining"},{"location":"#pattern-evaluation-evaluasi-guna-menemukan-sebuah-informasi","text":"Dalam tahap ini hasil dari data mining berupa pola-pola yang khas maupun model prediksi dievaluasi untuk menilai apakah hipotesa yang ada memang tercapai. Bila ternyata hasil yang diperoleh tidak sesuai hipotesa ada beberapa alternatif yang dapat diambil seperti : menjadikannya umpan balik untuk memperbaiki proses data mining, mencoba teknik data mining lain yang lebih sesuai, atau menerima hasil ini sebagai suatu hasil yang di luar dugaan yang mungkin bermanfaat. Ada beberapa teknik data mining yang menghasilkan hasil analisa berjumlah besar seperti analisis asosiasi. Visualisasi hasil analisa akan sangat membantu untuk memudahkan pemahaman dari hasil data mining.","title":"Pattern Evaluation evaluasi guna menemukan sebuah informasi"},{"location":"#knowledge-presentation-presentasi-pola-yang-ditemukan-untuk-menghasilkan-aksi","text":"Tahap terakhir dari proses data mining yang Merupakan visualisasi dan penyajian pengetahuan mengenai metode yang digunakan untuk memperoleh pengetahuan yang diperoleh pengguna dan bagaimana memformulasikan keputusan dari hasil analisis yang didapat.","title":"Knowledge Presentation presentasi pola yang ditemukan untuk menghasilkan aksi"},{"location":"#link-refrensi","text":"https://sis.binus.ac.id/2016/12/15/tahap-tahap-data-mining/ https://www.kajianpustaka.com/2017/09/data-mining.html https://rezqiwati.wordpress.com/2009/04/24/data-mining-%E2%80%93-proses-tahapan-dan-penerapannya/ https://purwasuka.web.id/pengertian-metode-dan-tahapan-data-mining.html","title":"Link Refrensi"},{"location":"Untitled/","text":"","title":"Untitled"},{"location":"authors-notes/","text":"About Author's \u00b6 Nama : Muhammad Amfahtori Wijarnoko Nim : 170441100012 Universitas : Trunojoyo Madura Alamat : dusun Kauman Rt 03 Rw 01 Sepande Candi Sidoarjo TTL : Sidoarjo, 09-11-1999 Education \u00b6 SD : SDN Sidokare 1 SMP : SMP PGRI 9 Sidoarjo SMA : SMKN 3 Buduran Sidoarjo (TKJ) Kuliah : Universitas Trunojoyo Madura","title":"Author's notes"},{"location":"authors-notes/#about-authors","text":"Nama : Muhammad Amfahtori Wijarnoko Nim : 170441100012 Universitas : Trunojoyo Madura Alamat : dusun Kauman Rt 03 Rw 01 Sepande Candi Sidoarjo TTL : Sidoarjo, 09-11-1999","title":"About Author's"},{"location":"authors-notes/#education","text":"SD : SDN Sidokare 1 SMP : SMP PGRI 9 Sidoarjo SMA : SMKN 3 Buduran Sidoarjo (TKJ) Kuliah : Universitas Trunojoyo Madura","title":"Education"},{"location":"contributing/","text":"../CONTRIBUTING.md","title":"Contributing"},{"location":"decision_tree/","text":"Metode Decision Tree \u00b6 Pengertian Decision Tree \u00b6 Secara singkat bahwa Decision Tree merupakan salah satu metode klasifikasi pada Text Mining. Klasifikasi adalah proses menemukan kumpulan pola atau fungsi-fungsi yang mendeskripsikan dan memisahkan kelas data satu dengan lainnya, untuk dapat digunakan untuk memprediksi data yang belum memiliki kelas data tertentu (Jianwei Han, 2001) . Decision tree memetakan berbagai alternatif yang mungkin untuk mengatasi suatu masalah, dan terdapat juga faktor-faktor kemungkinan yang dapat mempengaruhi alternatif tersebut beserta estimasi akhirnya jika memilih alternatif yang ada. Decision tree dimulai dengan sebuah root node(titik awal) yang dipakai oleh user untuk mengambil tindakan. Dari node root ini, user memecahnya sesuai dengan algoritma decision tree. Hasil akhirnya adalah sebuah decision tree dengan setiap cabangnya menunjukkan kemungkinan sekenario dari keputusan yang diambil serta hasilnya. Algoritma Perhitungan Decision Tree \u00b6 Menghitung Entropy total Dataset Menghitung Entropy dan Gain tiap atribut Membuat table perhitungan Node Membuat Node dengan hasil Gain tertinggi dari table Mengulangi langkah 2 - 5 hingga tidak ada node lagi Rumus Entropy \u00b6 Entropy mengukur ketidakpastian suatu variabel acak. Entropy menggunakan konsep probabilitas dalam menentukan besar entropy suatu kejadian. Kata entropi pertama kali dicetuskan oleh Rudolf Clausius pada tahun 1865, berasal dari bahasa Yunani \u03b5\u03bd\u03c4\u03c1\u03bf\u03c0\u03af\u03b1 [entrop\u00eda], \u03b5\u03bd- [en-] (masuk) dan \u03c4\u03c1\u03bf\u03c0\u03ae [trop\u0113] (mengubah, mengonversi). S=\\left\\{-\\frac{7}{12} *\\left(\\log 2\\left(\\frac{7}{12}\\right)\\right)\\right\\}+\\left\\{-\\frac{5}{12} *\\left(\\log 2\\left(\\frac{5}{12}\\right)\\right)\\right\\}=0,9798687107 S=\\left\\{-\\frac{7}{12} *\\left(\\log 2\\left(\\frac{7}{12}\\right)\\right)\\right\\}+\\left\\{-\\frac{5}{12} *\\left(\\log 2\\left(\\frac{5}{12}\\right)\\right)\\right\\}=0,9798687107 Contoh Perhitungan Sederhana \u00b6 Jumlah nilai Class benar dan salah : Benar : 7 Salah : 5 $$ S=\\left{-\\frac{7}{12} *\\left(\\log 2\\left(\\frac{7}{12}\\right)\\right)\\right}+\\left{-\\frac{5}{12} *\\left(\\log 2\\left(\\frac{5}{12}\\right)\\right)\\right}=0,9798687107 $$ Rumus Gain Ratio \u00b6 Gain merupakan sebuah sebuah pengurangan entrophy yang disebabkan oleh partisi berdasarkan suatu atribut. alam machine learning, ini dapat digunakan untuk menentukan urutan atribut atau mempersempit atribut yang dipilih. Urutan inilah yang akan membentuk pohon keputusan (decession tree). Contoh Kasus \u00b6 Diketahui dataset adalah sebagai berikut : Atribut : Pelatih, kandang sendiri, latihan, stamina, mental Kelas : Menang = ya atau tidak Jumlah data ada 12, terdiri dari : Ya = 7 Tidak = 5 1.Menghitung Entropy Total Dataset \u00b6 Berikut perhitungan Entropy : 2. Menghitung Entropy dan Gain Tiap Atribut \u00b6 Perhitungan Entropy tiap atribut: Tabel Perhitungan Node 1 dapat dilihat bahwa nilai gain terbesar adalah Gain pada atribut Mental, maka Mental yang akan menjadi node akar (root node) . Ada dua nilai dari atribut Mental yaitu PD dan Gerogi. Nilai atribut Gerogi sudah mengklasifikasikan kasus menjadi satu yaitu keputusannya \u201cTidak\u201d , sehingga tidak perlu dilakukan perhitungan lebih lanjut. Tetapi untuk nilai atribut PD masih perlu dilakukan perhitungan lagi , karena masih terdapat \u201cYa\u201d dan \u201cTidak\u201d. Gambar decision tree sementara : Berdasarkan pembentukan decision tree diatas, Node 1.1 akan dianalisis lebih lanjut. Berikut tabel data yang memiliki atribut Mental = PD 3. Menghitung Entropi Total dari Dataset Node 1.1 : \u00b6 4. Menghitung Entropi dan Gain dari Keseluruhan Atribut Node 1.1 : \u00b6 Selanjutnya menentukan atribut yang memiliki gain tertinggi untuk dibuatkan node berikutnya. Gain tertinggi adalah Latihan , sebesar 0.5435644433. Ada tiga nilai dari atribut Latihan yaitu Rutin, Jarang, dan Tidak ada. Nilai atribut Rutin sudah mengklasifikasikan kasus menjadi satu yaitu keputusannya \u201cYa\u201d , nilai atribut Jarang juga sudah mengklasifikasikan kasus menjadi satu yaitu keputusannya \u201cYa\u201d, sedangkan nilai atribut Tidak ada mengklasifikasi kasus menjadi satu, yaitu keputusannya \u201cTidak\u201d, sehingga tidak perlu melakukan perhitungan lebih lanjut. Dengan demikian decision tree akan tampak seperti berikut : Link Refrensi \u00b6 https://garudacyber.co.id/artikel/1545-pengertian-dan-penerapan-decision-tree http://newbiegameku.blogspot.com/2014/07/pengertian-decision-tree.html http://dyan123.blogspot.com/2012/03/pengertian-decision-tree.html http://student.blog.dinus.ac.id/devina09/2017/04/18/perhitungan-decision-tree-dengan-algoritma-c45/ http://student.blog.dinus.ac.id/fenny145167/2017/04/14/perhitungan-decision-tree-dengan-algoritma-c45/ https://id.wikipedia.org/wiki/Entropi https://rahmadya.com/2014/09/23/entropy/ http://itmbali.blogspot.com/2012/10/decision-tree-menggunakan-weka.html","title":"Metode Decision Tree"},{"location":"decision_tree/#metode-decision-tree","text":"","title":"Metode Decision Tree"},{"location":"decision_tree/#pengertian-decision-tree","text":"Secara singkat bahwa Decision Tree merupakan salah satu metode klasifikasi pada Text Mining. Klasifikasi adalah proses menemukan kumpulan pola atau fungsi-fungsi yang mendeskripsikan dan memisahkan kelas data satu dengan lainnya, untuk dapat digunakan untuk memprediksi data yang belum memiliki kelas data tertentu (Jianwei Han, 2001) . Decision tree memetakan berbagai alternatif yang mungkin untuk mengatasi suatu masalah, dan terdapat juga faktor-faktor kemungkinan yang dapat mempengaruhi alternatif tersebut beserta estimasi akhirnya jika memilih alternatif yang ada. Decision tree dimulai dengan sebuah root node(titik awal) yang dipakai oleh user untuk mengambil tindakan. Dari node root ini, user memecahnya sesuai dengan algoritma decision tree. Hasil akhirnya adalah sebuah decision tree dengan setiap cabangnya menunjukkan kemungkinan sekenario dari keputusan yang diambil serta hasilnya.","title":"Pengertian Decision Tree"},{"location":"decision_tree/#algoritma-perhitungan-decision-tree","text":"Menghitung Entropy total Dataset Menghitung Entropy dan Gain tiap atribut Membuat table perhitungan Node Membuat Node dengan hasil Gain tertinggi dari table Mengulangi langkah 2 - 5 hingga tidak ada node lagi","title":"Algoritma Perhitungan Decision Tree"},{"location":"decision_tree/#rumus-entropy","text":"Entropy mengukur ketidakpastian suatu variabel acak. Entropy menggunakan konsep probabilitas dalam menentukan besar entropy suatu kejadian. Kata entropi pertama kali dicetuskan oleh Rudolf Clausius pada tahun 1865, berasal dari bahasa Yunani \u03b5\u03bd\u03c4\u03c1\u03bf\u03c0\u03af\u03b1 [entrop\u00eda], \u03b5\u03bd- [en-] (masuk) dan \u03c4\u03c1\u03bf\u03c0\u03ae [trop\u0113] (mengubah, mengonversi). S=\\left\\{-\\frac{7}{12} *\\left(\\log 2\\left(\\frac{7}{12}\\right)\\right)\\right\\}+\\left\\{-\\frac{5}{12} *\\left(\\log 2\\left(\\frac{5}{12}\\right)\\right)\\right\\}=0,9798687107 S=\\left\\{-\\frac{7}{12} *\\left(\\log 2\\left(\\frac{7}{12}\\right)\\right)\\right\\}+\\left\\{-\\frac{5}{12} *\\left(\\log 2\\left(\\frac{5}{12}\\right)\\right)\\right\\}=0,9798687107","title":"Rumus Entropy"},{"location":"decision_tree/#contoh-perhitungan-sederhana","text":"Jumlah nilai Class benar dan salah : Benar : 7 Salah : 5 $$ S=\\left{-\\frac{7}{12} *\\left(\\log 2\\left(\\frac{7}{12}\\right)\\right)\\right}+\\left{-\\frac{5}{12} *\\left(\\log 2\\left(\\frac{5}{12}\\right)\\right)\\right}=0,9798687107 $$","title":"Contoh Perhitungan Sederhana"},{"location":"decision_tree/#rumus-gain-ratio","text":"Gain merupakan sebuah sebuah pengurangan entrophy yang disebabkan oleh partisi berdasarkan suatu atribut. alam machine learning, ini dapat digunakan untuk menentukan urutan atribut atau mempersempit atribut yang dipilih. Urutan inilah yang akan membentuk pohon keputusan (decession tree).","title":"Rumus Gain Ratio"},{"location":"decision_tree/#contoh-kasus","text":"Diketahui dataset adalah sebagai berikut : Atribut : Pelatih, kandang sendiri, latihan, stamina, mental Kelas : Menang = ya atau tidak Jumlah data ada 12, terdiri dari : Ya = 7 Tidak = 5","title":"Contoh Kasus"},{"location":"decision_tree/#1menghitung-entropy-total-dataset","text":"Berikut perhitungan Entropy :","title":"1.Menghitung Entropy Total Dataset"},{"location":"decision_tree/#2-menghitung-entropy-dan-gain-tiap-atribut","text":"Perhitungan Entropy tiap atribut: Tabel Perhitungan Node 1 dapat dilihat bahwa nilai gain terbesar adalah Gain pada atribut Mental, maka Mental yang akan menjadi node akar (root node) . Ada dua nilai dari atribut Mental yaitu PD dan Gerogi. Nilai atribut Gerogi sudah mengklasifikasikan kasus menjadi satu yaitu keputusannya \u201cTidak\u201d , sehingga tidak perlu dilakukan perhitungan lebih lanjut. Tetapi untuk nilai atribut PD masih perlu dilakukan perhitungan lagi , karena masih terdapat \u201cYa\u201d dan \u201cTidak\u201d. Gambar decision tree sementara : Berdasarkan pembentukan decision tree diatas, Node 1.1 akan dianalisis lebih lanjut. Berikut tabel data yang memiliki atribut Mental = PD","title":"2. Menghitung Entropy dan Gain Tiap Atribut"},{"location":"decision_tree/#3-menghitung-entropi-total-dari-dataset-node-11","text":"","title":"3. Menghitung Entropi Total dari Dataset Node 1.1 :"},{"location":"decision_tree/#4-menghitung-entropi-dan-gain-dari-keseluruhan-atribut-node-11","text":"Selanjutnya menentukan atribut yang memiliki gain tertinggi untuk dibuatkan node berikutnya. Gain tertinggi adalah Latihan , sebesar 0.5435644433. Ada tiga nilai dari atribut Latihan yaitu Rutin, Jarang, dan Tidak ada. Nilai atribut Rutin sudah mengklasifikasikan kasus menjadi satu yaitu keputusannya \u201cYa\u201d , nilai atribut Jarang juga sudah mengklasifikasikan kasus menjadi satu yaitu keputusannya \u201cYa\u201d, sedangkan nilai atribut Tidak ada mengklasifikasi kasus menjadi satu, yaitu keputusannya \u201cTidak\u201d, sehingga tidak perlu melakukan perhitungan lebih lanjut. Dengan demikian decision tree akan tampak seperti berikut :","title":"4. Menghitung Entropi dan Gain dari Keseluruhan Atribut Node 1.1 :"},{"location":"decision_tree/#link-refrensi","text":"https://garudacyber.co.id/artikel/1545-pengertian-dan-penerapan-decision-tree http://newbiegameku.blogspot.com/2014/07/pengertian-decision-tree.html http://dyan123.blogspot.com/2012/03/pengertian-decision-tree.html http://student.blog.dinus.ac.id/devina09/2017/04/18/perhitungan-decision-tree-dengan-algoritma-c45/ http://student.blog.dinus.ac.id/fenny145167/2017/04/14/perhitungan-decision-tree-dengan-algoritma-c45/ https://id.wikipedia.org/wiki/Entropi https://rahmadya.com/2014/09/23/entropy/ http://itmbali.blogspot.com/2012/10/decision-tree-menggunakan-weka.html","title":"Link Refrensi"},{"location":"knn/","text":"Metode KNN \u00b6 Pengertian KNN \u00b6 K-nearest neighbors atau knn adalah algoritma yang berfungsi untuk melakukan klasifikasi suatu data berdasarkan data pembelajaran ( train data sets ), yang diambil dari k tetangga terdekatnya ( nearest neighbors ). Dengan k merupakan banyaknya tetangga terdekat. Algoritma metode KNN sangatlah sederhana, bekerja dengan berdasarkan pada jarak terpendek dari sample uji. Algoritma Perhitungan KNN \u00b6 Menentukan parameter K sebagai banyaknya jumlah tetangga terdekat dengan objek baru. Menghitung jarak antar objek/data baru terhadap semua objek/data yan gtelah di training. Urutkan hasil perhitungan tersebut. Tentukan tetangga terdekat berdasarkan jarak minimum ke K. Tentukan kategori dari tetangga terdekat dengan objek/data. Gunakan kategori mayoritas sebagai klasifikasi objek/data baru. Rumus Euclidian Distance \u00b6 Euclidean distance adalah perhitungan jarak dari 2 buah titik dalam Euclidean space. Euclidean space diperkenalkan oleh Euclid, seorang matematikawan dari Yunani sekitar tahun 300 B.C.E. untuk mempelajari hubungan antara sudut dan jarak. Euclidean ini berkaitan dengan Teorema Phytagoras dan biasanya diterapkan pada 1, 2 dan 3 dimensi. Tapi juga sederhana jika diterapkan pada dimensi yang lebih tinggi. dist((x, y), (a, b)) = \u221a(x - a)\u00b2 + (y - b)\u00b2 dist((x, y), (a, b)) = \u221a(x - a)\u00b2 + (y - b)\u00b2 Contoh Perhitungan Sederhana \u00b6 dist((2, -1), (-2, 2)) = \u221a(2 - (-2))\u00b2 + ((-1) - 2)\u00b2 = \u221a(2 + 2)\u00b2 + (-1 - 2)\u00b2 = \u221a(4)\u00b2 + (-3)\u00b2 = \u221a16 + 9 = \u221a25 = 5. dist((2, -1), (-2, 2)) = \u221a(2 - (-2))\u00b2 + ((-1) - 2)\u00b2 = \u221a(2 + 2)\u00b2 + (-1 - 2)\u00b2 = \u221a(4)\u00b2 + (-3)\u00b2 = \u221a16 + 9 = \u221a25 = 5. Contoh Kasus \u00b6 Misalnya ada sebuah rumah yang berada tepat di tengah perbatasan antara Kota Bandung dan Kabupaten Bandung, sehingga pemerintah kesulitan untuk menentukan apakah rumah tersebut termasuk kedalam wilayah Kota Bandung atau Kabupaten Bandung. Kita bisa menentukannya dengan menggunakan Algoritma k-NN, yaitu dengan melibatkan jarak antara rumah tersebut dengan rumah-rumah yang ada disekitarnya (tetangganya). Pertama , kita harus menentukan jumlah tetangga yg akan kita perhitungkan (k), misalnya kita tentukan 3 tetangga terdekat ( k = 3 ). Kedua , hitung jarak setiap tetangga terhadap rumah tersebut, lalu urutkan hasilnya berdasarkan jarak, mulai dari yang terkecil ke yang terbesar. Ketiga , ambil 3 (k) tetangga yg paling dekat, lalu kita lihat masing-masing dari tetangga tersebut apakah termasuk kedalam wilayah Kota atau Kabupaten. Ada 2 kemungkinan: Bila dari 3 tetangga tersebut terdapat ada 2 rumah yg termasuk kedalam wilayah Kota Bandung, maka rumah tersebut termasuk kedalam wilayah Kota Bandung. Sebaliknya, bila dari 3 tetangga tersebut terdapat 2 rumah yg termasuk kedalam wilayah Kabupaten Bandung, maka rumah tersebut termasuk kedalam wilayah Kabupaten Bandung. Dalam menentukan nilai k, bila jumlah klasifikasi kita genap maka sebaiknya kita gunakan nilai k ganjil, dan begitu pula sebaliknya bila jumlah klasifikasi kita ganjil maka sebaiknya gunakan nilai k genap, karena jika tidak begitu, ada kemungkinan kita tidak akan mendapatkan jawaban. Link Refrensi \u00b6 https://www.ketutrare.com/2018/11/algoritma-k-nearest-neighbor-dan-contoh-soal.html http://cgeduntuksemua.blogspot.com/2012/03/pengertian-kelebihan-dan-kekurangan-k.html https://medium.com/bee-solution-partners/cara-kerja-algoritma-k-nearest-neighbor-k-nn-389297de543e https://id.wikipedia.org/wiki/KNN https://informatikalogi.com/algoritma-k-nn-k-nearest-neighbor/ https://www.advernesia.com/blog/data-science/pengertian-dan-cara-kerja-algoritma-k-nearest-neighbours-knn/ https://blogs.itb.ac.id/anugraha/2014/09/10/teori-pengukuran-jarak/ https://www.cut-the-knot.org/pythagoras/DistanceFormula.shtml","title":"Metode Knn"},{"location":"knn/#metode-knn","text":"","title":"Metode KNN"},{"location":"knn/#pengertian-knn","text":"K-nearest neighbors atau knn adalah algoritma yang berfungsi untuk melakukan klasifikasi suatu data berdasarkan data pembelajaran ( train data sets ), yang diambil dari k tetangga terdekatnya ( nearest neighbors ). Dengan k merupakan banyaknya tetangga terdekat. Algoritma metode KNN sangatlah sederhana, bekerja dengan berdasarkan pada jarak terpendek dari sample uji.","title":"Pengertian KNN"},{"location":"knn/#algoritma-perhitungan-knn","text":"Menentukan parameter K sebagai banyaknya jumlah tetangga terdekat dengan objek baru. Menghitung jarak antar objek/data baru terhadap semua objek/data yan gtelah di training. Urutkan hasil perhitungan tersebut. Tentukan tetangga terdekat berdasarkan jarak minimum ke K. Tentukan kategori dari tetangga terdekat dengan objek/data. Gunakan kategori mayoritas sebagai klasifikasi objek/data baru.","title":"Algoritma Perhitungan KNN"},{"location":"knn/#rumus-euclidian-distance","text":"Euclidean distance adalah perhitungan jarak dari 2 buah titik dalam Euclidean space. Euclidean space diperkenalkan oleh Euclid, seorang matematikawan dari Yunani sekitar tahun 300 B.C.E. untuk mempelajari hubungan antara sudut dan jarak. Euclidean ini berkaitan dengan Teorema Phytagoras dan biasanya diterapkan pada 1, 2 dan 3 dimensi. Tapi juga sederhana jika diterapkan pada dimensi yang lebih tinggi. dist((x, y), (a, b)) = \u221a(x - a)\u00b2 + (y - b)\u00b2 dist((x, y), (a, b)) = \u221a(x - a)\u00b2 + (y - b)\u00b2","title":"Rumus Euclidian Distance"},{"location":"knn/#contoh-perhitungan-sederhana","text":"dist((2, -1), (-2, 2)) = \u221a(2 - (-2))\u00b2 + ((-1) - 2)\u00b2 = \u221a(2 + 2)\u00b2 + (-1 - 2)\u00b2 = \u221a(4)\u00b2 + (-3)\u00b2 = \u221a16 + 9 = \u221a25 = 5. dist((2, -1), (-2, 2)) = \u221a(2 - (-2))\u00b2 + ((-1) - 2)\u00b2 = \u221a(2 + 2)\u00b2 + (-1 - 2)\u00b2 = \u221a(4)\u00b2 + (-3)\u00b2 = \u221a16 + 9 = \u221a25 = 5.","title":"Contoh Perhitungan Sederhana"},{"location":"knn/#contoh-kasus","text":"Misalnya ada sebuah rumah yang berada tepat di tengah perbatasan antara Kota Bandung dan Kabupaten Bandung, sehingga pemerintah kesulitan untuk menentukan apakah rumah tersebut termasuk kedalam wilayah Kota Bandung atau Kabupaten Bandung. Kita bisa menentukannya dengan menggunakan Algoritma k-NN, yaitu dengan melibatkan jarak antara rumah tersebut dengan rumah-rumah yang ada disekitarnya (tetangganya). Pertama , kita harus menentukan jumlah tetangga yg akan kita perhitungkan (k), misalnya kita tentukan 3 tetangga terdekat ( k = 3 ). Kedua , hitung jarak setiap tetangga terhadap rumah tersebut, lalu urutkan hasilnya berdasarkan jarak, mulai dari yang terkecil ke yang terbesar. Ketiga , ambil 3 (k) tetangga yg paling dekat, lalu kita lihat masing-masing dari tetangga tersebut apakah termasuk kedalam wilayah Kota atau Kabupaten. Ada 2 kemungkinan: Bila dari 3 tetangga tersebut terdapat ada 2 rumah yg termasuk kedalam wilayah Kota Bandung, maka rumah tersebut termasuk kedalam wilayah Kota Bandung. Sebaliknya, bila dari 3 tetangga tersebut terdapat 2 rumah yg termasuk kedalam wilayah Kabupaten Bandung, maka rumah tersebut termasuk kedalam wilayah Kabupaten Bandung. Dalam menentukan nilai k, bila jumlah klasifikasi kita genap maka sebaiknya kita gunakan nilai k ganjil, dan begitu pula sebaliknya bila jumlah klasifikasi kita ganjil maka sebaiknya gunakan nilai k genap, karena jika tidak begitu, ada kemungkinan kita tidak akan mendapatkan jawaban.","title":"Contoh Kasus"},{"location":"knn/#link-refrensi","text":"https://www.ketutrare.com/2018/11/algoritma-k-nearest-neighbor-dan-contoh-soal.html http://cgeduntuksemua.blogspot.com/2012/03/pengertian-kelebihan-dan-kekurangan-k.html https://medium.com/bee-solution-partners/cara-kerja-algoritma-k-nearest-neighbor-k-nn-389297de543e https://id.wikipedia.org/wiki/KNN https://informatikalogi.com/algoritma-k-nn-k-nearest-neighbor/ https://www.advernesia.com/blog/data-science/pengertian-dan-cara-kerja-algoritma-k-nearest-neighbours-knn/ https://blogs.itb.ac.id/anugraha/2014/09/10/teori-pengukuran-jarak/ https://www.cut-the-knot.org/pythagoras/DistanceFormula.shtml","title":"Link Refrensi"},{"location":"license/","text":"License \u00b6 MIT License Copyright \u00a9 2016 - 2019 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright \u00a9 2016 - 2019 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"extensions/cod_knn/","text":"Program KNN Python \u00b6 Download Data Excel \u00b6 Datasets yang digunakan adalah Hearth Disease dari Kaggle yang memiliki karakteristik data sebagai berikut : Jumlah data = 303 Jumlah kolom = 14 Jumlah class = 2 Jumlah data class 0 = 138 Jumlah data class 1 = 165 Pembagian data train, dan data test. dikarenakan data yang digunakan adalah data kecil maka data dipecah menjadi 5 bagian, pembagiannya adalah seperti berikut : Class 0 =138 / 5 =27.6 Class 1 = 165 / 5 = 33 Data train : Class 0 = 28 Class 1 = 33 Data test : Class 0 = 110 Class 1 = 132 Program dan Penjelasan \u00b6 Import library \u00b6 import library diperlukan agar kita dapat menggunakan fungsi-fungsi yang ada dalam library tersebut. berikut beberapa library yang diimport dan penjelasannya : math : digunakan untuk fungsi matematika pandas : digunakan untuk menampilkan array dan beberapa operasi array lainnya matplotlib.pyplot : digunakan untuk membuat grafk import math import pandas as pd import matplotlib.pyplot as plt Import csv dan memasukkan data \u00b6 dataset = pd.read_csv('heart.csv') col_age = dataset.iloc[:, 0].values col_sex = dataset.iloc[:, 1].values col_cp = dataset.iloc[:, 2].values col_tres = dataset.iloc[:, 3].values col_chol = dataset.iloc[:, 4].values col_fbs = dataset.iloc[:, 5].values col_rest = dataset.iloc[:, 6].values col_thal = dataset.iloc[:, 7].values col_exa = dataset.iloc[:, 8].values col_old = dataset.iloc[:, 9].values col_slop = dataset.iloc[:, 10].values col_cha = dataset.iloc[:, 11].values col_thal2 = dataset.iloc[:, 12].values col_target = dataset.iloc[:, 13].values Membuat variable \u00b6 Variable data training \u00b6 age= [] sex= [] cp= [] tres= [] chol= [] fbs= [] rest= [] thal= [] exa= [] old= [] slop= [] cha= [] thal2= [] target= [] variable data test \u00b6 age_dt= [] sex_dt= [] cp_dt= [] tres_dt= [] chol_dt= [] fbs_dt= [] rest_dt= [] thal_dt= [] exa_dt= [] old_dt= [] slop_dt= [] cha_dt= [] thal2_dt= [] target_dt= [] Variable penunjang operasi \u00b6 knn_graf=[] Hasil=[] Hasil1=[] benar=[] benar1=[] salah=[] salah1=[] data=[] data1=[] akurasi=[] akurasi1=[] jml_data=303 jml_data_test=242 jml_data_train=62 jml_data_train_0=28 jml_data_train_1=33 Membuat fungsi \u00b6 Fungsi membagi data dan memasukkan ke data train \u00b6 def input_data_train_0 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] ==0 and a<jml_data_train_0): data_out.append(data_in[i]) a=a+1 def input_data_train_1 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 1 and a<jml_data_train_1): data_out.append(data_in[i]) a=a+1 Fungsi membagi data dan memasukkan ke data test \u00b6 def input_data_test_0 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 0): a+=1 if(a>jml_data_train_0): data_out.append(data_in[i]) def input_data_test_1 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 1): a+=1 if(a>jml_data_train_1): data_out.append(data_in[i]) Fungsi perhitungan Euclidian distance \u00b6 def euclidian(train1,train2,train3,train4,train5,train6,train7,train8,train9,train10,train11,train12,train13,train14, test1,test2,test3,test4,test5,test6,test7,test8,test9,test10,test11,test12,test13,test14, k,out,out2): for i in range(len(test1)): dist1=[] target=[] coba=0 zz=0 for a in range(len(train1)): dist = math.sqrt(((train1[a] - test1[i])**2) + ((train2[a] - test2[i])**2) + ((train3[a] - test3[i])**2) + ((train4[a] - test4[i])**2) + ((train5[a] - test5[i])**2) + ((train6[a] - test6[i])**2) + ((train7[a] - test7[i])**2) + ((train8[a] - test8[i])**2) + ((train9[a] - test9[i])**2) + ((train10[a] - test10[i])**2) + ((train11[a] - test11[i])**2) + ((train12[a] - test12[i])**2) + ((train13[a] - test13[i])**2)) dist1.append(dist) dist1,target = (list(t) for t in zip(*sorted(zip(dist1,train14)))) #print (len(target)) for z in range(2,k+2): z1=z-2 if (target[z1]==0) : coba+=1 #print(z1) zz=k/2 #print(coba) if (zz<=coba): a=0 out.append(a) else : a=1 out.append(a) if (zz<coba): a=0 out2.append(a) else : a=1 out2.append(a) del dist1 del target coba=0 Fungsi perbandingan \u00b6 def perbandingan(data_asli,data_perbandingan,out,out2,out3,out4): a=0 for x in range(len(data_asli)): if (data_asli[x]==data_perbandingan[x]): a+=1 out.append(a) out2.append(jml_data_test) out3.append(a/jml_data_test) out4.append(jml_data_test-a) Memasukkan data pada data training \u00b6 input_data_train_0(col_age,age) input_data_train_0(col_sex,sex) input_data_train_0(col_cp,cp) input_data_train_0(col_tres,tres) input_data_train_0(col_chol,chol) input_data_train_0(col_fbs,fbs) input_data_train_0(col_rest,rest) input_data_train_0(col_thal,thal) input_data_train_0(col_exa,exa) input_data_train_0(col_old,old) input_data_train_0(col_cha,cha) input_data_train_0(col_slop,slop) input_data_train_0(col_thal2,thal2) input_data_train_0(col_target,target) input_data_train_1(col_age,age) input_data_train_1(col_sex,sex) input_data_train_1(col_cp,cp) input_data_train_1(col_tres,tres) input_data_train_1(col_chol,chol) input_data_train_1(col_fbs,fbs) input_data_train_1(col_rest,rest) input_data_train_1(col_thal,thal) input_data_train_1(col_exa,exa) input_data_train_1(col_old,old) input_data_train_1(col_cha,cha) input_data_train_1(col_slop,slop) input_data_train_1(col_thal2,thal2) input_data_train_1(col_target,target) Memasukkan data pada data test \u00b6 input_data_test_0(col_age,age_dt) input_data_test_0(col_sex,sex_dt) input_data_test_0(col_cp,cp_dt) input_data_test_0(col_tres,tres_dt) input_data_test_0(col_chol,chol_dt) input_data_test_0(col_fbs,fbs_dt) input_data_test_0(col_rest,rest_dt) input_data_test_0(col_thal,thal_dt) input_data_test_0(col_exa,exa_dt) input_data_test_0(col_old,old_dt) input_data_test_0(col_cha,cha_dt) input_data_test_0(col_slop,slop_dt) input_data_test_0(col_thal2,thal2_dt) input_data_test_0(col_target,target_dt) input_data_test_1(col_age,age_dt) input_data_test_1(col_sex,sex_dt) input_data_test_1(col_cp,cp_dt) input_data_test_1(col_tres,tres_dt) input_data_test_1(col_chol,chol_dt) input_data_test_1(col_fbs,fbs_dt) input_data_test_1(col_rest,rest_dt) input_data_test_1(col_thal,thal_dt) input_data_test_1(col_exa,exa_dt) input_data_test_1(col_old,old_dt) input_data_test_1(col_cha,cha_dt) input_data_test_1(col_slop,slop_dt) input_data_test_1(col_thal2,thal2_dt) input_data_test_1(col_target,target_dt) Membuat badan program \u00b6 print (\"masukkan nilai k untuk perulangan\") k_awal=int(input(\"masukkan nilai k awal :\")) k_akhir=int(input(\"masukkan nilai k akhir :\")) for knnn in range(k_awal,k_akhir+1): del Hasil del Hasil1 Hasil=[] Hasil1=[] euclidian(age,sex,cp,tres,chol,fbs,rest,thal,exa,old,cha,slop,thal2,target, age_dt,sex_dt,cp_dt,tres_dt,chol_dt,fbs_dt,rest_dt,thal_dt,exa_dt,old_dt,cha_dt,slop_dt,thal2_dt,target_dt, knnn,Hasil,Hasil1) perbandingan(target_dt,Hasil,benar,data,akurasi,salah) perbandingan(target_dt,Hasil1,benar1,data1,akurasi1,salah1) #print(Hasil) knn_graf.append(knnn) print(\"K \",knnn,\"sukses dijalankan\") Menampilkan hasil perhitungan \u00b6 df = pd.DataFrame({'knn':knn_graf,'data_benar0':benar, 'Akurasi0':akurasi, 'data_benar1':benar1, 'Akurasi1':akurasi1,'Jml_data':data}) df2=df print(\"\") df.sort_values(by=['data_benar0'],inplace=True,ascending=False) print (df.to_string(index=False)) print(\"\") df.sort_values(by=['data_benar1'],inplace=True,ascending=False) print (df.to_string(index=False)) df.sort_values(by=['knn'],inplace=True,ascending=True) Membuat grafik dan keterangan \u00b6 ax=plt.gca() df.plot(kind=\"scatter\",x='knn',y='data_benar0',color=\"green\",ax=ax) df.plot(kind=\"scatter\",x='knn',y='data_benar1',color=\"red\",ax=ax) plt.plot(knn_graf,benar,color=\"green\") plt.plot(knn_graf,benar1,color=\"red\") plt.xlabel(\"Nilai K\") plt.ylabel(\"Data Benar\") plt.grid(True) plt.show() print(\"\") print (df2.to_string(index=False))","title":"Program Knn"},{"location":"extensions/cod_knn/#program-knn-python","text":"","title":"Program KNN Python"},{"location":"extensions/cod_knn/#download-data-excel","text":"Datasets yang digunakan adalah Hearth Disease dari Kaggle yang memiliki karakteristik data sebagai berikut : Jumlah data = 303 Jumlah kolom = 14 Jumlah class = 2 Jumlah data class 0 = 138 Jumlah data class 1 = 165 Pembagian data train, dan data test. dikarenakan data yang digunakan adalah data kecil maka data dipecah menjadi 5 bagian, pembagiannya adalah seperti berikut : Class 0 =138 / 5 =27.6 Class 1 = 165 / 5 = 33 Data train : Class 0 = 28 Class 1 = 33 Data test : Class 0 = 110 Class 1 = 132","title":"Download Data Excel"},{"location":"extensions/cod_knn/#program-dan-penjelasan","text":"","title":"Program dan Penjelasan"},{"location":"extensions/cod_knn/#import-library","text":"import library diperlukan agar kita dapat menggunakan fungsi-fungsi yang ada dalam library tersebut. berikut beberapa library yang diimport dan penjelasannya : math : digunakan untuk fungsi matematika pandas : digunakan untuk menampilkan array dan beberapa operasi array lainnya matplotlib.pyplot : digunakan untuk membuat grafk import math import pandas as pd import matplotlib.pyplot as plt","title":"Import library"},{"location":"extensions/cod_knn/#import-csv-dan-memasukkan-data","text":"dataset = pd.read_csv('heart.csv') col_age = dataset.iloc[:, 0].values col_sex = dataset.iloc[:, 1].values col_cp = dataset.iloc[:, 2].values col_tres = dataset.iloc[:, 3].values col_chol = dataset.iloc[:, 4].values col_fbs = dataset.iloc[:, 5].values col_rest = dataset.iloc[:, 6].values col_thal = dataset.iloc[:, 7].values col_exa = dataset.iloc[:, 8].values col_old = dataset.iloc[:, 9].values col_slop = dataset.iloc[:, 10].values col_cha = dataset.iloc[:, 11].values col_thal2 = dataset.iloc[:, 12].values col_target = dataset.iloc[:, 13].values","title":"Import csv dan memasukkan data"},{"location":"extensions/cod_knn/#membuat-variable","text":"","title":"Membuat variable"},{"location":"extensions/cod_knn/#variable-data-training","text":"age= [] sex= [] cp= [] tres= [] chol= [] fbs= [] rest= [] thal= [] exa= [] old= [] slop= [] cha= [] thal2= [] target= []","title":"Variable data training"},{"location":"extensions/cod_knn/#variable-data-test","text":"age_dt= [] sex_dt= [] cp_dt= [] tres_dt= [] chol_dt= [] fbs_dt= [] rest_dt= [] thal_dt= [] exa_dt= [] old_dt= [] slop_dt= [] cha_dt= [] thal2_dt= [] target_dt= []","title":"variable data test"},{"location":"extensions/cod_knn/#variable-penunjang-operasi","text":"knn_graf=[] Hasil=[] Hasil1=[] benar=[] benar1=[] salah=[] salah1=[] data=[] data1=[] akurasi=[] akurasi1=[] jml_data=303 jml_data_test=242 jml_data_train=62 jml_data_train_0=28 jml_data_train_1=33","title":"Variable penunjang operasi"},{"location":"extensions/cod_knn/#membuat-fungsi","text":"","title":"Membuat fungsi"},{"location":"extensions/cod_knn/#fungsi-membagi-data-dan-memasukkan-ke-data-train","text":"def input_data_train_0 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] ==0 and a<jml_data_train_0): data_out.append(data_in[i]) a=a+1 def input_data_train_1 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 1 and a<jml_data_train_1): data_out.append(data_in[i]) a=a+1","title":"Fungsi membagi data dan memasukkan ke data train"},{"location":"extensions/cod_knn/#fungsi-membagi-data-dan-memasukkan-ke-data-test","text":"def input_data_test_0 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 0): a+=1 if(a>jml_data_train_0): data_out.append(data_in[i]) def input_data_test_1 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 1): a+=1 if(a>jml_data_train_1): data_out.append(data_in[i])","title":"Fungsi membagi data dan memasukkan ke data test"},{"location":"extensions/cod_knn/#fungsi-perhitungan-euclidian-distance","text":"def euclidian(train1,train2,train3,train4,train5,train6,train7,train8,train9,train10,train11,train12,train13,train14, test1,test2,test3,test4,test5,test6,test7,test8,test9,test10,test11,test12,test13,test14, k,out,out2): for i in range(len(test1)): dist1=[] target=[] coba=0 zz=0 for a in range(len(train1)): dist = math.sqrt(((train1[a] - test1[i])**2) + ((train2[a] - test2[i])**2) + ((train3[a] - test3[i])**2) + ((train4[a] - test4[i])**2) + ((train5[a] - test5[i])**2) + ((train6[a] - test6[i])**2) + ((train7[a] - test7[i])**2) + ((train8[a] - test8[i])**2) + ((train9[a] - test9[i])**2) + ((train10[a] - test10[i])**2) + ((train11[a] - test11[i])**2) + ((train12[a] - test12[i])**2) + ((train13[a] - test13[i])**2)) dist1.append(dist) dist1,target = (list(t) for t in zip(*sorted(zip(dist1,train14)))) #print (len(target)) for z in range(2,k+2): z1=z-2 if (target[z1]==0) : coba+=1 #print(z1) zz=k/2 #print(coba) if (zz<=coba): a=0 out.append(a) else : a=1 out.append(a) if (zz<coba): a=0 out2.append(a) else : a=1 out2.append(a) del dist1 del target coba=0","title":"Fungsi perhitungan Euclidian distance"},{"location":"extensions/cod_knn/#fungsi-perbandingan","text":"def perbandingan(data_asli,data_perbandingan,out,out2,out3,out4): a=0 for x in range(len(data_asli)): if (data_asli[x]==data_perbandingan[x]): a+=1 out.append(a) out2.append(jml_data_test) out3.append(a/jml_data_test) out4.append(jml_data_test-a)","title":"Fungsi perbandingan"},{"location":"extensions/cod_knn/#memasukkan-data-pada-data-training","text":"input_data_train_0(col_age,age) input_data_train_0(col_sex,sex) input_data_train_0(col_cp,cp) input_data_train_0(col_tres,tres) input_data_train_0(col_chol,chol) input_data_train_0(col_fbs,fbs) input_data_train_0(col_rest,rest) input_data_train_0(col_thal,thal) input_data_train_0(col_exa,exa) input_data_train_0(col_old,old) input_data_train_0(col_cha,cha) input_data_train_0(col_slop,slop) input_data_train_0(col_thal2,thal2) input_data_train_0(col_target,target) input_data_train_1(col_age,age) input_data_train_1(col_sex,sex) input_data_train_1(col_cp,cp) input_data_train_1(col_tres,tres) input_data_train_1(col_chol,chol) input_data_train_1(col_fbs,fbs) input_data_train_1(col_rest,rest) input_data_train_1(col_thal,thal) input_data_train_1(col_exa,exa) input_data_train_1(col_old,old) input_data_train_1(col_cha,cha) input_data_train_1(col_slop,slop) input_data_train_1(col_thal2,thal2) input_data_train_1(col_target,target)","title":"Memasukkan data pada data training"},{"location":"extensions/cod_knn/#memasukkan-data-pada-data-test","text":"input_data_test_0(col_age,age_dt) input_data_test_0(col_sex,sex_dt) input_data_test_0(col_cp,cp_dt) input_data_test_0(col_tres,tres_dt) input_data_test_0(col_chol,chol_dt) input_data_test_0(col_fbs,fbs_dt) input_data_test_0(col_rest,rest_dt) input_data_test_0(col_thal,thal_dt) input_data_test_0(col_exa,exa_dt) input_data_test_0(col_old,old_dt) input_data_test_0(col_cha,cha_dt) input_data_test_0(col_slop,slop_dt) input_data_test_0(col_thal2,thal2_dt) input_data_test_0(col_target,target_dt) input_data_test_1(col_age,age_dt) input_data_test_1(col_sex,sex_dt) input_data_test_1(col_cp,cp_dt) input_data_test_1(col_tres,tres_dt) input_data_test_1(col_chol,chol_dt) input_data_test_1(col_fbs,fbs_dt) input_data_test_1(col_rest,rest_dt) input_data_test_1(col_thal,thal_dt) input_data_test_1(col_exa,exa_dt) input_data_test_1(col_old,old_dt) input_data_test_1(col_cha,cha_dt) input_data_test_1(col_slop,slop_dt) input_data_test_1(col_thal2,thal2_dt) input_data_test_1(col_target,target_dt)","title":"Memasukkan data pada data test"},{"location":"extensions/cod_knn/#membuat-badan-program","text":"print (\"masukkan nilai k untuk perulangan\") k_awal=int(input(\"masukkan nilai k awal :\")) k_akhir=int(input(\"masukkan nilai k akhir :\")) for knnn in range(k_awal,k_akhir+1): del Hasil del Hasil1 Hasil=[] Hasil1=[] euclidian(age,sex,cp,tres,chol,fbs,rest,thal,exa,old,cha,slop,thal2,target, age_dt,sex_dt,cp_dt,tres_dt,chol_dt,fbs_dt,rest_dt,thal_dt,exa_dt,old_dt,cha_dt,slop_dt,thal2_dt,target_dt, knnn,Hasil,Hasil1) perbandingan(target_dt,Hasil,benar,data,akurasi,salah) perbandingan(target_dt,Hasil1,benar1,data1,akurasi1,salah1) #print(Hasil) knn_graf.append(knnn) print(\"K \",knnn,\"sukses dijalankan\")","title":"Membuat badan program"},{"location":"extensions/cod_knn/#menampilkan-hasil-perhitungan","text":"df = pd.DataFrame({'knn':knn_graf,'data_benar0':benar, 'Akurasi0':akurasi, 'data_benar1':benar1, 'Akurasi1':akurasi1,'Jml_data':data}) df2=df print(\"\") df.sort_values(by=['data_benar0'],inplace=True,ascending=False) print (df.to_string(index=False)) print(\"\") df.sort_values(by=['data_benar1'],inplace=True,ascending=False) print (df.to_string(index=False)) df.sort_values(by=['knn'],inplace=True,ascending=True)","title":"Menampilkan hasil perhitungan"},{"location":"extensions/cod_knn/#membuat-grafik-dan-keterangan","text":"ax=plt.gca() df.plot(kind=\"scatter\",x='knn',y='data_benar0',color=\"green\",ax=ax) df.plot(kind=\"scatter\",x='knn',y='data_benar1',color=\"red\",ax=ax) plt.plot(knn_graf,benar,color=\"green\") plt.plot(knn_graf,benar1,color=\"red\") plt.xlabel(\"Nilai K\") plt.ylabel(\"Data Benar\") plt.grid(True) plt.show() print(\"\") print (df2.to_string(index=False))","title":"Membuat grafik dan keterangan"},{"location":"extensions/cod_knn_full/","text":"Full Program KNN Pyhon \u00b6 Running Program \u00b6 Inputan parameter : Laporan status iterasi Laporan pengurutan data, jika selisih data sama maka data dianggap 0 Laporan pengurutan data, jika selisih data sama maka data dianggap 1 Grafik laporan nilai knn tertinggi merah jika data dengan selisih sama dianggap 1 hijau jika data dengan selisih sama dianggap 0 Full Program \u00b6 import math import pandas as pd import matplotlib.pyplot as plt dataset = pd.read_csv('heart.csv') col_age = dataset.iloc[:, 0].values col_sex = dataset.iloc[:, 1].values col_cp = dataset.iloc[:, 2].values col_tres = dataset.iloc[:, 3].values col_chol = dataset.iloc[:, 4].values col_fbs = dataset.iloc[:, 5].values col_rest = dataset.iloc[:, 6].values col_thal = dataset.iloc[:, 7].values col_exa = dataset.iloc[:, 8].values col_old = dataset.iloc[:, 9].values col_slop = dataset.iloc[:, 10].values col_cha = dataset.iloc[:, 11].values col_thal2 = dataset.iloc[:, 12].values col_target = dataset.iloc[:, 13].values age= [] sex= [] cp= [] tres= [] chol= [] fbs= [] rest= [] thal= [] exa= [] old= [] slop= [] cha= [] thal2= [] target= [] age_dt= [] sex_dt= [] cp_dt= [] tres_dt= [] chol_dt= [] fbs_dt= [] rest_dt= [] thal_dt= [] exa_dt= [] old_dt= [] slop_dt= [] cha_dt= [] thal2_dt= [] target_dt= [] knn_graf=[] Hasil=[] Hasil1=[] benar=[] benar1=[] salah=[] salah1=[] data=[] data1=[] akurasi=[] akurasi1=[] jml_data=303 jml_data_test=242 jml_data_train=62 jml_data_train_0=28 jml_data_train_1=33 def input_data_train_0 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] ==0 and a<jml_data_train_0): data_out.append(data_in[i]) a=a+1 def input_data_test_0 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 0): a+=1 if(a>jml_data_train_0): data_out.append(data_in[i]) def input_data_train_1 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 1 and a<jml_data_train_1): data_out.append(data_in[i]) a=a+1 def input_data_test_1 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 1): a+=1 if(a>jml_data_train_1): data_out.append(data_in[i]) def euclidian(train1,train2,train3,train4,train5,train6,train7,train8,train9,train10,train11,train12,train13,train14, test1,test2,test3,test4,test5,test6,test7,test8,test9,test10,test11,test12,test13,test14, k,out,out2): for i in range(len(test1)): dist1=[] target=[] coba=0 zz=0 for a in range(len(train1)): dist = math.sqrt(((train1[a] - test1[i])**2) + ((train2[a] - test2[i])**2) + ((train3[a] - test3[i])**2) + ((train4[a] - test4[i])**2) + ((train5[a] - test5[i])**2) + ((train6[a] - test6[i])**2) + ((train7[a] - test7[i])**2) + ((train8[a] - test8[i])**2) + ((train9[a] - test9[i])**2) + ((train10[a] - test10[i])**2) + ((train11[a] - test11[i])**2) + ((train12[a] - test12[i])**2) + ((train13[a] - test13[i])**2)) dist1.append(dist) dist1,target = (list(t) for t in zip(*sorted(zip(dist1,train14)))) #print (len(target)) for z in range(2,k+2): z1=z-2 if (target[z1]==0) : coba+=1 #print(z1) zz=k/2 #print(coba) if (zz<=coba): a=0 out.append(a) else : a=1 out.append(a) if (zz<coba): a=0 out2.append(a) else : a=1 out2.append(a) del dist1 del target coba=0 def perbandingan(data_asli,data_perbandingan,out,out2,out3,out4): a=0 for x in range(len(data_asli)): if (data_asli[x]==data_perbandingan[x]): a+=1 out.append(a) out2.append(jml_data_test) out3.append(a/jml_data_test) out4.append(jml_data_test-a) input_data_train_0(col_age,age) input_data_train_0(col_sex,sex) input_data_train_0(col_cp,cp) input_data_train_0(col_tres,tres) input_data_train_0(col_chol,chol) input_data_train_0(col_fbs,fbs) input_data_train_0(col_rest,rest) input_data_train_0(col_thal,thal) input_data_train_0(col_exa,exa) input_data_train_0(col_old,old) input_data_train_0(col_cha,cha) input_data_train_0(col_slop,slop) input_data_train_0(col_thal2,thal2) input_data_train_0(col_target,target) input_data_train_1(col_age,age) input_data_train_1(col_sex,sex) input_data_train_1(col_cp,cp) input_data_train_1(col_tres,tres) input_data_train_1(col_chol,chol) input_data_train_1(col_fbs,fbs) input_data_train_1(col_rest,rest) input_data_train_1(col_thal,thal) input_data_train_1(col_exa,exa) input_data_train_1(col_old,old) input_data_train_1(col_cha,cha) input_data_train_1(col_slop,slop) input_data_train_1(col_thal2,thal2) input_data_train_1(col_target,target) input_data_test_0(col_age,age_dt) input_data_test_0(col_sex,sex_dt) input_data_test_0(col_cp,cp_dt) input_data_test_0(col_tres,tres_dt) input_data_test_0(col_chol,chol_dt) input_data_test_0(col_fbs,fbs_dt) input_data_test_0(col_rest,rest_dt) input_data_test_0(col_thal,thal_dt) input_data_test_0(col_exa,exa_dt) input_data_test_0(col_old,old_dt) input_data_test_0(col_cha,cha_dt) input_data_test_0(col_slop,slop_dt) input_data_test_0(col_thal2,thal2_dt) input_data_test_0(col_target,target_dt) input_data_test_1(col_age,age_dt) input_data_test_1(col_sex,sex_dt) input_data_test_1(col_cp,cp_dt) input_data_test_1(col_tres,tres_dt) input_data_test_1(col_chol,chol_dt) input_data_test_1(col_fbs,fbs_dt) input_data_test_1(col_rest,rest_dt) input_data_test_1(col_thal,thal_dt) input_data_test_1(col_exa,exa_dt) input_data_test_1(col_old,old_dt) input_data_test_1(col_cha,cha_dt) input_data_test_1(col_slop,slop_dt) input_data_test_1(col_thal2,thal2_dt) input_data_test_1(col_target,target_dt) print (\"masukkan nilai k untuk perulangan\") k_awal=int(input(\"masukkan nilai k awal :\")) k_akhir=int(input(\"masukkan nilai k akhir :\")) for knnn in range(k_awal,k_akhir+1): del Hasil del Hasil1 Hasil=[] Hasil1=[] euclidian(age,sex,cp,tres,chol,fbs,rest,thal,exa,old,cha,slop,thal2,target, age_dt,sex_dt,cp_dt,tres_dt,chol_dt,fbs_dt,rest_dt,thal_dt,exa_dt,old_dt,cha_dt,slop_dt,thal2_dt,target_dt, knnn,Hasil,Hasil1) perbandingan(target_dt,Hasil,benar,data,akurasi,salah) perbandingan(target_dt,Hasil1,benar1,data1,akurasi1,salah1) #print(Hasil) knn_graf.append(knnn) print(\"K \",knnn,\"sukses dijalankan\") df = pd.DataFrame({'knn':knn_graf,'data_benar0':benar, 'Akurasi0':akurasi, 'data_benar1':benar1, 'Akurasi1':akurasi1,'Jml_data':data}) df2=df print(\"\") df.sort_values(by=['data_benar0'],inplace=True,ascending=False) print (df.to_string(index=False)) print(\"\") df.sort_values(by=['data_benar1'],inplace=True,ascending=False) print (df.to_string(index=False)) df.sort_values(by=['knn'],inplace=True,ascending=True) ax=plt.gca() df.plot(kind=\"scatter\",x='knn',y='data_benar0',color=\"green\",ax=ax) df.plot(kind=\"scatter\",x='knn',y='data_benar1',color=\"red\",ax=ax) plt.plot(knn_graf,benar,color=\"green\") plt.plot(knn_graf,benar1,color=\"red\") plt.xlabel(\"Nilai K\") plt.ylabel(\"Data Benar\") plt.grid(True) plt.show() print(\"\") print (df2.to_string(index=False)) Sumber Pemrograman \u00b6 https://towardsdatascience.com/a-guide-to-pandas-and-matplotlib-for-data-exploration-56fad95f951c http://queirozf.com/entries/pandas-dataframe-plot-examples-with-matplotlib-pyplot https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html https://stackoverflow.com/questions/17839973/constructing-pandas-dataframe-from-values-in-variables-gives-valueerror-if-usi https://www.w3schools.com/python/python_for_loops.asp https://stackoverflow.com/questions/8237647/clear-variable-in-python/52463466 https://stackoverflow.com/questions/21682804/pop-remove-items-out-of-a-python-tuple https://stackoverflow.com/questions/30323439/raising-elements-of-a-list-to-a-power https://stackoverflow.com/questions/2643850/what-is-a-good-way-to-do-countif-in-python https://www.geeksforgeeks.org/python-sort-values-first-list-using-second-list/ https://stackoverflow.com/questions/11601961/sorting-multiple-lists-based-on-a-single-list-in-python https://stackoverflow.com/questions/22211737/how-to-sort-a-pandas-dataframe-by-index https://datatofish.com/sort-pandas-dataframe/ https://stackoverflow.com/questions/37787698/how-to-sort-pandas-dataframe-from-one-column https://pandas.pydata.org/pandas-docs/version/0.19/generated/pandas.DataFrame.sort.html https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html https://jakevdp.github.io/PythonDataScienceHandbook/02.02-the-basics-of-numpy-arrays.html http://cs231n.github.io/python-numpy-tutorial/ https://code.tutsplus.com/id/tutorials/introducing-pandas--cms-26514 https://www.codepolitan.com/mengenal-list-dan-berbagai-operasinya-di-python https://www.geeksforgeeks.org/python-list-sort/ https://www.kaggle.com/ronitf/heart-disease-uci https://www.kaggle.com/mcdonalds/nutrition-facts","title":"Program Knn Refrensi"},{"location":"extensions/cod_knn_full/#full-program-knn-pyhon","text":"","title":"Full Program KNN Pyhon"},{"location":"extensions/cod_knn_full/#running-program","text":"Inputan parameter : Laporan status iterasi Laporan pengurutan data, jika selisih data sama maka data dianggap 0 Laporan pengurutan data, jika selisih data sama maka data dianggap 1 Grafik laporan nilai knn tertinggi merah jika data dengan selisih sama dianggap 1 hijau jika data dengan selisih sama dianggap 0","title":"Running Program"},{"location":"extensions/cod_knn_full/#full-program","text":"import math import pandas as pd import matplotlib.pyplot as plt dataset = pd.read_csv('heart.csv') col_age = dataset.iloc[:, 0].values col_sex = dataset.iloc[:, 1].values col_cp = dataset.iloc[:, 2].values col_tres = dataset.iloc[:, 3].values col_chol = dataset.iloc[:, 4].values col_fbs = dataset.iloc[:, 5].values col_rest = dataset.iloc[:, 6].values col_thal = dataset.iloc[:, 7].values col_exa = dataset.iloc[:, 8].values col_old = dataset.iloc[:, 9].values col_slop = dataset.iloc[:, 10].values col_cha = dataset.iloc[:, 11].values col_thal2 = dataset.iloc[:, 12].values col_target = dataset.iloc[:, 13].values age= [] sex= [] cp= [] tres= [] chol= [] fbs= [] rest= [] thal= [] exa= [] old= [] slop= [] cha= [] thal2= [] target= [] age_dt= [] sex_dt= [] cp_dt= [] tres_dt= [] chol_dt= [] fbs_dt= [] rest_dt= [] thal_dt= [] exa_dt= [] old_dt= [] slop_dt= [] cha_dt= [] thal2_dt= [] target_dt= [] knn_graf=[] Hasil=[] Hasil1=[] benar=[] benar1=[] salah=[] salah1=[] data=[] data1=[] akurasi=[] akurasi1=[] jml_data=303 jml_data_test=242 jml_data_train=62 jml_data_train_0=28 jml_data_train_1=33 def input_data_train_0 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] ==0 and a<jml_data_train_0): data_out.append(data_in[i]) a=a+1 def input_data_test_0 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 0): a+=1 if(a>jml_data_train_0): data_out.append(data_in[i]) def input_data_train_1 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 1 and a<jml_data_train_1): data_out.append(data_in[i]) a=a+1 def input_data_test_1 (data_in,data_out): a=0 for i in range (len (data_in)): if (col_target[i] == 1): a+=1 if(a>jml_data_train_1): data_out.append(data_in[i]) def euclidian(train1,train2,train3,train4,train5,train6,train7,train8,train9,train10,train11,train12,train13,train14, test1,test2,test3,test4,test5,test6,test7,test8,test9,test10,test11,test12,test13,test14, k,out,out2): for i in range(len(test1)): dist1=[] target=[] coba=0 zz=0 for a in range(len(train1)): dist = math.sqrt(((train1[a] - test1[i])**2) + ((train2[a] - test2[i])**2) + ((train3[a] - test3[i])**2) + ((train4[a] - test4[i])**2) + ((train5[a] - test5[i])**2) + ((train6[a] - test6[i])**2) + ((train7[a] - test7[i])**2) + ((train8[a] - test8[i])**2) + ((train9[a] - test9[i])**2) + ((train10[a] - test10[i])**2) + ((train11[a] - test11[i])**2) + ((train12[a] - test12[i])**2) + ((train13[a] - test13[i])**2)) dist1.append(dist) dist1,target = (list(t) for t in zip(*sorted(zip(dist1,train14)))) #print (len(target)) for z in range(2,k+2): z1=z-2 if (target[z1]==0) : coba+=1 #print(z1) zz=k/2 #print(coba) if (zz<=coba): a=0 out.append(a) else : a=1 out.append(a) if (zz<coba): a=0 out2.append(a) else : a=1 out2.append(a) del dist1 del target coba=0 def perbandingan(data_asli,data_perbandingan,out,out2,out3,out4): a=0 for x in range(len(data_asli)): if (data_asli[x]==data_perbandingan[x]): a+=1 out.append(a) out2.append(jml_data_test) out3.append(a/jml_data_test) out4.append(jml_data_test-a) input_data_train_0(col_age,age) input_data_train_0(col_sex,sex) input_data_train_0(col_cp,cp) input_data_train_0(col_tres,tres) input_data_train_0(col_chol,chol) input_data_train_0(col_fbs,fbs) input_data_train_0(col_rest,rest) input_data_train_0(col_thal,thal) input_data_train_0(col_exa,exa) input_data_train_0(col_old,old) input_data_train_0(col_cha,cha) input_data_train_0(col_slop,slop) input_data_train_0(col_thal2,thal2) input_data_train_0(col_target,target) input_data_train_1(col_age,age) input_data_train_1(col_sex,sex) input_data_train_1(col_cp,cp) input_data_train_1(col_tres,tres) input_data_train_1(col_chol,chol) input_data_train_1(col_fbs,fbs) input_data_train_1(col_rest,rest) input_data_train_1(col_thal,thal) input_data_train_1(col_exa,exa) input_data_train_1(col_old,old) input_data_train_1(col_cha,cha) input_data_train_1(col_slop,slop) input_data_train_1(col_thal2,thal2) input_data_train_1(col_target,target) input_data_test_0(col_age,age_dt) input_data_test_0(col_sex,sex_dt) input_data_test_0(col_cp,cp_dt) input_data_test_0(col_tres,tres_dt) input_data_test_0(col_chol,chol_dt) input_data_test_0(col_fbs,fbs_dt) input_data_test_0(col_rest,rest_dt) input_data_test_0(col_thal,thal_dt) input_data_test_0(col_exa,exa_dt) input_data_test_0(col_old,old_dt) input_data_test_0(col_cha,cha_dt) input_data_test_0(col_slop,slop_dt) input_data_test_0(col_thal2,thal2_dt) input_data_test_0(col_target,target_dt) input_data_test_1(col_age,age_dt) input_data_test_1(col_sex,sex_dt) input_data_test_1(col_cp,cp_dt) input_data_test_1(col_tres,tres_dt) input_data_test_1(col_chol,chol_dt) input_data_test_1(col_fbs,fbs_dt) input_data_test_1(col_rest,rest_dt) input_data_test_1(col_thal,thal_dt) input_data_test_1(col_exa,exa_dt) input_data_test_1(col_old,old_dt) input_data_test_1(col_cha,cha_dt) input_data_test_1(col_slop,slop_dt) input_data_test_1(col_thal2,thal2_dt) input_data_test_1(col_target,target_dt) print (\"masukkan nilai k untuk perulangan\") k_awal=int(input(\"masukkan nilai k awal :\")) k_akhir=int(input(\"masukkan nilai k akhir :\")) for knnn in range(k_awal,k_akhir+1): del Hasil del Hasil1 Hasil=[] Hasil1=[] euclidian(age,sex,cp,tres,chol,fbs,rest,thal,exa,old,cha,slop,thal2,target, age_dt,sex_dt,cp_dt,tres_dt,chol_dt,fbs_dt,rest_dt,thal_dt,exa_dt,old_dt,cha_dt,slop_dt,thal2_dt,target_dt, knnn,Hasil,Hasil1) perbandingan(target_dt,Hasil,benar,data,akurasi,salah) perbandingan(target_dt,Hasil1,benar1,data1,akurasi1,salah1) #print(Hasil) knn_graf.append(knnn) print(\"K \",knnn,\"sukses dijalankan\") df = pd.DataFrame({'knn':knn_graf,'data_benar0':benar, 'Akurasi0':akurasi, 'data_benar1':benar1, 'Akurasi1':akurasi1,'Jml_data':data}) df2=df print(\"\") df.sort_values(by=['data_benar0'],inplace=True,ascending=False) print (df.to_string(index=False)) print(\"\") df.sort_values(by=['data_benar1'],inplace=True,ascending=False) print (df.to_string(index=False)) df.sort_values(by=['knn'],inplace=True,ascending=True) ax=plt.gca() df.plot(kind=\"scatter\",x='knn',y='data_benar0',color=\"green\",ax=ax) df.plot(kind=\"scatter\",x='knn',y='data_benar1',color=\"red\",ax=ax) plt.plot(knn_graf,benar,color=\"green\") plt.plot(knn_graf,benar1,color=\"red\") plt.xlabel(\"Nilai K\") plt.ylabel(\"Data Benar\") plt.grid(True) plt.show() print(\"\") print (df2.to_string(index=False))","title":"Full Program"},{"location":"extensions/cod_knn_full/#sumber-pemrograman","text":"https://towardsdatascience.com/a-guide-to-pandas-and-matplotlib-for-data-exploration-56fad95f951c http://queirozf.com/entries/pandas-dataframe-plot-examples-with-matplotlib-pyplot https://pandas.pydata.org/pandas-docs/stable/user_guide/visualization.html https://stackoverflow.com/questions/17839973/constructing-pandas-dataframe-from-values-in-variables-gives-valueerror-if-usi https://www.w3schools.com/python/python_for_loops.asp https://stackoverflow.com/questions/8237647/clear-variable-in-python/52463466 https://stackoverflow.com/questions/21682804/pop-remove-items-out-of-a-python-tuple https://stackoverflow.com/questions/30323439/raising-elements-of-a-list-to-a-power https://stackoverflow.com/questions/2643850/what-is-a-good-way-to-do-countif-in-python https://www.geeksforgeeks.org/python-sort-values-first-list-using-second-list/ https://stackoverflow.com/questions/11601961/sorting-multiple-lists-based-on-a-single-list-in-python https://stackoverflow.com/questions/22211737/how-to-sort-a-pandas-dataframe-by-index https://datatofish.com/sort-pandas-dataframe/ https://stackoverflow.com/questions/37787698/how-to-sort-pandas-dataframe-from-one-column https://pandas.pydata.org/pandas-docs/version/0.19/generated/pandas.DataFrame.sort.html https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html https://jakevdp.github.io/PythonDataScienceHandbook/02.02-the-basics-of-numpy-arrays.html http://cs231n.github.io/python-numpy-tutorial/ https://code.tutsplus.com/id/tutorials/introducing-pandas--cms-26514 https://www.codepolitan.com/mengenal-list-dan-berbagai-operasinya-di-python https://www.geeksforgeeks.org/python-list-sort/ https://www.kaggle.com/ronitf/heart-disease-uci https://www.kaggle.com/mcdonalds/nutrition-facts","title":"Sumber Pemrograman"}]}